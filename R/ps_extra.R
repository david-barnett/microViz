#' ps_extra S3 class
#'
#' S3 class to store a list of "extras" alongside a phyloseq object
#' @examples
#' data("dietswap", package = "microbiome")
#'
#' new_ps_extra_info()
#' print(new_ps_extra_info(), all = TRUE)
#' ps_extra <- new_ps_extra(dietswap)
#' ps_extra
#' @export
#' @noRd
print.ps_extra <- function(x, ...) {
  stopif_ps_extra(x)
}

# helper for summarising taxatree_stats objects
taxatree_stats_summary <- function(df) {
  n <- length(unique(df[["taxon"]]))
  r <- unique(df[["rank"]])
  t <- levels(df[["term"]])
  cat(n, "taxa at", length(r), "ranks:", paste(r, collapse = ", "), "\n")
  cat(length(t), "terms:", paste(t, collapse = ", "))
}
# helper for summarising tax_stats objects
tax_stats_summary <- function(df) {
  n <- length(unique(df[["taxon"]]))
  t <- unique(df[["term"]])
  cat(n, "taxa at rank of", df[["rank"]][1], "\n")
  cat(length(t), "terms:", paste(t, collapse = ", "))
}

#' @export
#' @noRd
print.ps_extra_info <- function(x, ..., all = TRUE) {
  stop("ps_extra class is defunct")
}

#' @param ps phyloseq object
#' @param dist dist class distance matrix
#' @param ord ordination object
#' @param info info about the other 3 args
#' @noRd
new_ps_extra <- function(ps,
                         dist = NULL,
                         ord = NULL,
                         info = new_ps_extra_info()) {
  stopifnot(methods::is(ps, "phyloseq"))
  stopifnot(identical(dist, NULL) && !inherits(dist, "dist"))
  stopifnot(inherits(info, "ps_extra_info"))
  psx <- structure(
    .Data = list(ps = ps, dist = dist, ord = ord, info = info),
    class = c("ps_extra", "list")
  )
  return(psx)
}

#' @param tax_agg aggregation level from tax_agg() (if any)
#' @param tax_transform transformation name from tax_transform() (if any)
#' @param tax_scale scaling specified in tax_scale() if any
#' @param distMethod distance method in dist_calc()
#' @param ordMethod ordination method in ord_calc()
#' @param constraints constraints (if any) for ord_calc()
#' @param conditions conditions (if any) for ord_calc()
#' @noRd
new_ps_extra_info <- function(tax_agg = NA_character_,
                              tax_transform = NA_character_,
                              tax_scale = NA_character_,
                              distMethod = NA_character_,
                              ordMethod = NA_character_,
                              constraints = NA_character_,
                              conditions = NA_character_) {
  info <- c(
    tax_agg = tax_agg, tax_transform = tax_transform,
    tax_scale = tax_scale,
    distMethod = distMethod,
    ordMethod = ordMethod, constraints = constraints, conditions = conditions
  )
  stopifnot(all(is.character(info)))

  psxi <- structure(.Data = info, class = "ps_extra_info")
  return(psxi)
}

# internal helper to convert plain phyloseq to ps_extra or leave ps_extra as is
as_ps_extra <- function(ps) {
  if (methods::is(ps, "phyloseq")) {
    return(new_ps_extra(ps = ps))
  } else if (inherits(ps, "ps_extra")) {
    return(ps)
  } else {
    stop(
      "Cannot coerce object of class '", paste(class(ps), collapse = "' '"),
      "' into a ps_extra. \nObject must be a phyloseq or already a ps_extra!"
    )
  }
}

#' Convert old format "ps_extra" objects to new "psExtra" objects
#'
#' This will only be necessary if you have saved old format "ps_extra" objects
#' generated by an old microViz version (< 0.10.0), and you cannot or do not
#' want to regenerate these old format objects from your original phyloseq object.
#'
#' @param ps_extra
#' an old format "ps_extra" object,
#' as generated by old microViz versions (< 0.10.0)
#'
#' @return new format "psExtra" S4 object
#' @export
#'
#' @examples
#' # read your old saved 'ps_extra' object that you want to keep using
#' # oldObject <- readRDS("old-object-path.rds")
#' # newObject <- upgrade_ps_extra_to_psExtra(oldObject)
#' # continue with your next analysis or plotting steps...
upgrade_ps_extra_to_psExtra <- function(ps_extra) {
  if (is(ps_extra, "phyloseq")) stop("object does not need conversion!")
  if (!inherits(ps_extra, "ps_extra")) stop("object is not a 'ps_extra'")
  newInfo <- upgrade_ps_extra_info_to_psExtraInfo(ps_extra[["info"]])

  psX <- psExtra(
    ps = ps_extra[["ps"]], info = newInfo, counts = ps_extra[["counts"]],
    dist = ps_extra[["dist"]], ord = ps_extra[["ord"]],
    permanova = ps_extra[["permanova"]],
    bdisp = ps_extra[["bdisp"]],
    taxatree_models = ps_extra[["taxatree_models"]],
    taxatree_stats = ps_extra[["taxatree_stats"]],
    tax_models = ps_extra[["tax_models"]],
    tax_stats = ps_extra[["tax_stats"]]
  )
  return(psX)
}

upgrade_ps_extra_info_to_psExtraInfo <- function(ps_extra_info) {
  stopifnot(is.null(ps_extra_info) || inherits(ps_extra_info, "ps_extra_info"))
  if (!is.null(ps_extra_info)) {
    return(new_psExtraInfo())
  }
  LIST <- as.list(ps_extra_info) # so missing element selection returns NULL
  NEW <- new_psExtraInfo(
    tax_agg = naOrNull2zeroLenChr(LIST[["tax_agg"]]),
    tax_trans = naOrNull2zeroLenChr(LIST[["tax_transform"]]),
    tax_scale = naOrNull2zeroLenChr(LIST[["tax_scale"]]),
    dist_method = naOrNull2zeroLenChr(LIST[["distMethod"]]),
    ord_info = new_psExtraOrdInfo(
      method = naOrNull2zeroLenChr(LIST[["ordMethod"]]),
      constraints = naOrNull2zeroLenChr(LIST[["constraints"]]),
      conditions = naOrNull2zeroLenChr(LIST[["conditions"]])
    )
  )
  return(NEW)
}


naOrNull2zeroLenChr <- function(x) {
  if (rlang::is_null(x) || rlang::is_na(x)) x <- character()
  return(x)
}

stopif_ps_extra <- function(object, argName = NULL, Ncallers = 1) {
  if (!inherits(object, "ps_extra")) {
    return(object)
  }
  rlang::abort(call = rlang::caller_env(n = Ncallers), message = c(
    "x" = paste("argument", argName, "is a deprecated 'ps_extra' object"),
    "!" = "If possible, regenerate the object with the current microViz version",
    "i" = paste(
      "Or convert your ps_extra object to the new psExtra class",
      "with {.help [{.fun upgrade_ps_extra_to_psExtra}](microViz::upgrade_ps_extra_to_psExtra)}"
    )
  ))
}
