data("dietswap", package = "microbiome")

# manual taxa ordering -------------------------------------------------------

fixed_order <- c(
  "Fusobacteria", "Cyanobacteria", "Verrucomicrobia", "Spirochaetes",
  "Actinobacteria", "Firmicutes", "Proteobacteria", "Bacteroidetes"
)

test_that("fixing tax order of comp_barplot works", {
  p <- dietswap %>%
    ps_filter(timepoint == 1) %>%
    comp_barplot(
      tax_level = "Phylum", n_taxa = 8,
      sample_order = "bray",
      tax_order = fixed_order
    ) + ggplot2::coord_flip()

  expect_equal(
    object = levels(p$data$unique),
    expected = c("other", rev(fixed_order))
  )
})


# standard dynamic ordering of samples and taxa stays consistent -------------

top8bysum <- c(
  "other", "Allistipes et rel.", "Clostridium symbiosum et rel.",
  "Clostridium cellulosi et rel.", "Faecalibacterium prausnitzii et rel.",
  "Prevotella oralis et rel.", "Oscillospira guillermondii et rel.",
  "Bacteroides vulgatus et rel.", "Prevotella melaninogenica et rel."
)

test_that("comp_barplot doesn't change", {
  local_edition(3)

  p <- dietswap %>%
    ps_filter(timepoint == 1) %>%
    comp_barplot(
      tax_level = "Genus", n_taxa = 8,
      sample_order = "aitchison",
      merge_other = FALSE,
      tax_order = sum,
    ) + ggplot2::coord_flip()

  # vdiffr visual test
  vdiffr::expect_doppelganger(title = "comp_barplot", fig = p)

  expect_snapshot_csv(
    name = "unique_taxa_order",
    object = levels(p$data$unique)
  )
  expect_snapshot_csv(
    name = "SAMPLE_order",
    object = levels(p$data$SAMPLE)
  )
  expect_equal(object = levels(p$data$top), expected = top8bysum)
})

test_that("list of plots generated by group_by works", {
  local_edition(3)
  plots <- dietswap %>%
    ps_filter(timepoint == 1) %>%
    comp_barplot(
      tax_level = "Genus",
      sample_order = "bray",
      group_by = "bmi_group",
      keep_all_vars = FALSE
    )
  expect_equal(
    object = names(plots),
    expected = c("overweight", "lean", "obese")
  )

  for (p in names(plots)) {
    expect_snapshot_csv(
      name = paste0("unique_taxa_order-", p),
      object = levels(plots[[p]]$data$unique)
    )
    expect_snapshot_csv(
      name = paste0("SAMPLE_order-", p),
      object = levels(plots[[p]]$data$SAMPLE)
    )
    expect_snapshot(print(p))
    expect_equal(levels(plots[[p]]$data$top), top8bysum)

    # check dropping variables (for faster melting) works (keep_all_vars = F)
    # only label 'SAMPLE' and group 'bmi_group' variables kept
    expect_equal(
      object = colnames(plots[[p]]$data),
      expected = c(
        "OTU", "Sample", "Abundance", "SAMPLE", "bmi_group", "Phylum",
        "Family", "Genus", "top", "separate", "unique"
      )
    )
  }
})



# test internal helper --------------------------------------------------------

test_that("tt_add_topN_var helper works as expected", {
  local_edition(3)
  tt <- microViz:::tt_add_topN_var(
    phyloseq::tax_table(dietswap),
    N = 4, other = "things", varname = "test"
  )
  expect_snapshot(
    print(head(x = tt, 6), width = 80)
  )
})


# manual sample ordering errors -----------------------------------------------

test_that("sample_order arg errors nicely when invalid names provided", {
  # invalid names (not in sample_names)
  expect_error(
    object =
      comp_barplot(dietswap, tax_level = "Genus", sample_order = letters),
    regexp =
      "1 or more of the sample_order values are not phyloseq sample_names"
  )

  # incorrect number of otherwise valid sample names
  expect_error(
    object = comp_barplot(
      ps = dietswap, tax_level = "Genus",
      sample_order = phyloseq::sample_names(dietswap)[1:10]
    ),
    regexp = "Length of sample_order must be 1 or same as number of samples!"
  )
})

